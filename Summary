Assignment Overview:
The purpose of this assignment is to implement a robust client-server application capable of handling
RMI connections. The assignment aims to implement a multi-threaded key-value store server that
can process GET, PUT, and DELETE commands from clients over Java RMI.
The client application should be resilient to server failures and unresponsiveness, utilizing a
timeout mechanism to handle such scenarios gracefully and alerting the user. Additionally, the client should log all
server timeout incidents with precise timestamps to facilitate troubleshooting.
From what I understand, the scope of the assignment involves designing and implementing multi-threaded
server capabilities. Emphasis is placed on ensuring robust communication, error handling, and
logging mechanisms to create a reliable and maintainable distributed system. The server should be
able to handle requests from multiple clients simultaneously, thereby handling mutual exclusion
as well. The server is using thread pools to handle these concurrent requests and maintain
consistency using the ConcurrentHashMap. Implementing the 2 phase protocol for the PUT and
DELETE operations ensures consistency among the multiple instances of server and client.

Technical Impression:
Working on this assignment provided a comprehensive understanding of the complexities involved
in developing robust client-server applications using Java RMI. In the previous project, a single
instance of the Key value store server was used. Now, this server needs to be scaled up such that
there are 5 replicas so that clients can request any of these server instances for the operations.
This increases server bandwidth and availability as well.

One of the challenges was ensuring consistency was maintained when the clients can contact any of
the 5 replicas of the server. This was implemented through a 2 phase commit protocol for the
PUT and DELETE operations on the server instances, where these instances are assumed to not fail.
When a client issues a PUT or DELETE operation to any server replica, the receiving replica ensures
that the updates have been received by all replicas (via ACKs) and committed.

This process also involved thorough logging mechanisms to understand the complete flow of requests and
responses made by clients, even though they may not be in the same order because of different
threads. Exception handling was also implemented so that the server or the client do not crash
and exit gracefully when errored.

A practical use case for this client-server application would be in a distributed caching system,
where the server acts as a cache store for frequently accessed data, and multiple clients
such as web applications may read and update the cache concurrently.
This system can significantly improve performance and reduce the load on a central database by distributing data storage and
retrieval operations.